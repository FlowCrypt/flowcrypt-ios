//
//  OrganisationalRule.swift
//  FlowCrypt
//
//  Created by Yevhen Kyivskyi on 20.05.2021.
//  Copyright Â© 2021 FlowCrypt Limited. All rights reserved.
//

import Foundation

enum DomainRulesFlag: String, Codable {

    case noPRVBackup = "NO_PRV_BACKUP"
    case noPRVCreate = "NO_PRV_CREATE"
    case noKeyManagerPubLookup = "NO_KEY_MANAGER_PUB_LOOKUP"
    case PRVAutoimportOrAutogen = "PRV_AUTOIMPORT_OR_AUTOGEN"
    case passphraseQuietAutogen = "PASS_PHRASE_QUIET_AUTOGEN"
    case enforceAttesterSubmit = "ENFORCE_ATTESTER_SUBMIT"
    case noAttesterSubmit = "NO_ATTESTER_SUBMIT"
    case useLegacyAttesterSubmit = "USE_LEGACY_ATTESTER_SUBMIT"
    case defaultRememberPassphrase = "DEFAULT_REMEMBER_PASS_PHRASE"
    case hideArmorMeta = "HIDE_ARMOR_META"
}

struct DomainRules: Codable, Equatable {

    let flags: [DomainRulesFlag]?
    let customKeyserverUrl: String?
    let keyManagerUrl: String?
    let disallowAttesterSearchForDomains: [String]?
    let enforceKeygenAlgo: String?
    let enforceKeygenExpireMonths: Int?
}

/// Organisational rules, set domain-wide, and delivered from FlowCrypt Backend
/// These either enforce, alter or forbid various behavior to fit customer needs
class OrganisationalRules {

    private let domainRules: DomainRules
    let domain: String

    init(domainRules: DomainRules, domain: String) {
        self.domainRules = domainRules
        self.domain = domain
    }

    init?(domainRules: DomainRules, email: String) {
        guard let recipientDomain = email.recipientDomain else {
            return nil
        }

        self.domain = recipientDomain
        self.domainRules = domainRules
    }

    /// Internal company SKS-like public key server to trust above Attester
    var customSksPubkeyServer: String? {
        domainRules.customKeyserverUrl
    }

    /// an internal org FlowCrypt Email Key Manager instance, can manage both public and private keys
    /// use this method when using for PRV sync
    var keyManagerUrlForPrivateKeys: String? {
        domainRules.keyManagerUrl
    }

    /// an internal org FlowCrypt Email Key Manager instance, can manage both public and private keys
    /// use this method when using for PUB sync
    var keyManagerUrlForPublicKeys: String? {
        (domainRules.flags ?? []).contains(.noKeyManagerPubLookup)
            ? nil
            : domainRules.keyManagerUrl
    }

    /// use when finding out if EKM is in use, to change functionality without actually neededing the EKM
    var isUsingKeyManager: Bool {
        domainRules.keyManagerUrl != nil
    }

    /// Enforce a key algo for keygen, eg rsa2048,rsa4096,curve25519
    var enforcedKeygenAlgo: String? {
        domainRules.enforceKeygenAlgo
    }

    /// Some orgs want to have newly generated keys include self-signatures that expire some time in the future.
    var getEnforcedKeygenExpirationMonths: Int? {
        domainRules.enforceKeygenExpireMonths
    }

    /// Some orgs expect 100% of their private keys to be imported from elsewhere (and forbid keygen in the extension)
    var canCreateKeys: Bool {
        !(domainRules.flags ?? []).contains(.noPRVCreate)
    }

    /// Some orgs want to forbid backing up of public keys (such as inbox or other methods)
    var canBackupKeys: Bool {
        !(domainRules.flags ?? []).contains(.noPRVBackup)
    }

    /// (normally, during setup, if a public key is submitted to Attester and there is
    /// a conflicting key already submitted, the issue will be skipped)
    /// Some orgs want to make sure that their public key gets submitted to attester and conflict errors are NOT ignored:
    var mustSubmitAttester: Bool {
        (domainRules.flags ?? []).contains(.enforceAttesterSubmit)
    }

    /// Normally, during setup, "remember pass phrase" is unchecked
    /// This option will cause "remember pass phrase" option to be checked by default
    /// This behavior is also enabled as a byproduct of PASS_PHRASE_QUIET_AUTOGEN
    var shouldRememberPassphraseByDefault: Bool {
        (domainRules.flags ?? []).contains(.defaultRememberPassphrase) || mustAutogenPassPhraseQuietly
    }

    /// This is to be used for customers who run their own FlowCrypt Email Key Manager
    /// If a key can be found on FEKM, it will be auto imported
    /// If not, it will be autogenerated and stored there
    var mustAutoImportOrAutogenPrvWithKeyManager: Bool {
        if !(domainRules.flags ?? []).contains(.PRVAutoimportOrAutogen) {
            return false
        }

        if keyManagerUrlForPrivateKeys == nil {
            assertionFailure("Wrong org rules config: using PRV_AUTOIMPORT_OR_AUTOGEN without key_manager_url")
            return false
        }
        return true
    }

    /// When generating keys, user will not be prompted to choose a pass phrase
    /// Instead a pass phrase will be automatically generated, and stored locally
    /// The pass phrase will NOT be displayed to user, and it will never be asked of the user
    /// This creates the smoothest user experience, for organisations that use full-disk-encryption and don't need pass phrase protection
    var mustAutogenPassPhraseQuietly: Bool {
        (domainRules.flags ?? []).contains(.passphraseQuietAutogen)
    }

    /// Some orgs prefer to forbid publishing public keys publicly
    var canSubmitPubToAttester: Bool {
        !(domainRules.flags ?? []).contains(.noAttesterSubmit)
    }

    /// Some orgs have a list of email domains where they do NOT want such emails to be looked up on public sources (such as Attester)
    /// This is because they already have other means to obtain public keys for these domains, such as from their own internal keyserver
    func canLookupThisRecipientOnAttester(recipient email: String) -> Bool {
        !(domainRules.disallowAttesterSearchForDomains ?? []).contains(email.recipientDomain ?? "")
    }

    /// Some orgs use flows that are only implemented in POST /initial/legacy_submit and not in POST /pub/email@corp.co:
    ///  -> enforcing that submitted keys match customer key server
    /// Until the newer endpoint is ready, this flag will point users in those orgs to the original endpoint
    var useLegacyAttesterSubmit: Bool {
        (domainRules.flags ?? []).contains(.useLegacyAttesterSubmit)
    }

    /// With this option, sent messages won't have any comment/version in armor, imported keys get imported without armor
    var shouldHideArmorMeta: Bool {
        (domainRules.flags ?? []).contains(.hideArmorMeta)
    }
}
